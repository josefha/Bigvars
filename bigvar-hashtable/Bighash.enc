
module Bighash

import Supervisorh

EMBED
uint64_t strHash(char* input);
BODY
uint64_t strHash(char* input) {
    uint64_t hash = 5381;
    char *str = input;
    int c;

    while ((c = *str++))
        hash = ((hash << 5) + hash) + c;
    return hash;
}
END

linear class Bighash[k,v]
    var supervisor : Supervisor[k,v]
    var f : k -> uint

    def init(f: k -> uint) : unit
        this.f = f
        this.supervisor = new Supervisor[k,v](f)
    end

    def copy() : Bighash[k,v]
        var f = this.f
        var bighash = new Bighash[k,v](fun(key:k) => f(key))
        bighash.supervisor = this.supervisor.copy()
        consume bighash
    end

    def put(key:k,value:v) : unit
        get(this.supervisor.put(key,value))
    end

    def get(key:k) : v
        this.supervisor.get(key)
    end

    def remove(key:k) : unit
        get(this.supervisor.remove(key))
    end

    def getMany(keys:[k]) : [v]
        this.supervisor.getMany(keys)
    end

    def elements() : [v]
        this.supervisor.elements()
    end

    def removeMany(keys:[k]) : unit
        this.supervisor.removeMany(keys)
    end

    def keys() : [k]
        this.supervisor.keys()
    end

    def clear() : unit
        this.supervisor.clear()
    end

    def rehash() : unit
        this.supervisor.rehash()
    end

    def hasKey(key:k) : bool
        this.supervisor.hasKey(key)
    end

    def contains(value:v) : bool
        this.supervisor.contains(value)
    end

    ------------------------------------

    def extend(key:k, value:v) : unit
        this.supervisor.extend(key,value)
    end

    def extendAll(key:k, values:[v]) : unit
        this.supervisor.extendAll(key,values)
    end

    def getValues(key:k) : [v]
        this.supervisor.getValues(key)
    end

    def mapper(m:(k,v)->[(v,k)]) : unit
        this.supervisor.mapper(m)
    end

    def getInfo() : unit
        this.supervisor.getInfo()
    end
end

-- fun generateFromStringArray(input:[String]) : Bighash[int,String]
--
--     var bighash = new Bighash[int,String](fun(k:int) => intID(k))
--
--     repeat i <- |input| do
--         --println(i)
--         bighash.put(i,input(i))
--     end
--
--     bighash
-- end

fun stringID_NEW(s : String) : uint
    --var charpointer = EMBED (uint) (uint64_t) #{s.getData()}; END
    var ans = EMBED (uint) (uint64_t) strHash(#{s.getData()}); END
    --println("charpointer = {} -> hash : {}",charpointer,ans)
    ans
end

--(uint64_t)
fun intID(key : int) : uint
    EMBED (uint) (uint64_t) #{key}; END
end
