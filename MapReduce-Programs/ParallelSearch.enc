

import MapReduce
import GeneratedGraphs
import Bighash

--import CTimer

active class Main

    var mp : MapReduce[int,Node,int,Node]
    var mapf : (int,Node) -> [(int, Node)]
    var reducef : (int, [Node]) -> (int, Node)

    def main() : unit
        println("Running Parallel breadth-first shortest-path on 10 000 nodes")
        var input = GenerateAdjacencyList(graph10000()) --g500()) -- g5000_3() --big50000_10()
        input = this.setStartNode(7,consume input)

        this.mp = new MapReduce[int,Node,int,Node](fun(k:int) => nodeID(k))
        this.mapf = fun(key:int,value:Node) => map(key,value)
        this.reducef = fun(key:int,values:[Node]) => reduce(key,values)

        var result = this.iterate(25,consume input)

        --printResult(consume result)
        --println("\n DONE")
        ()
    end

    def iterate(max:int, input:Bighash[int,Node]) : Bighash[int,Node]
        var result = input.copy()
        repeat i <- max do
            --println("Iteration {}", i)
            var done = true
            -- iterate all nodes and if some node is undone break this loop and mp.run()
            for key <- result.keys() do
                var value = result.get(key)
                if value.color > 0 then
                    done = false
                    break
                end
            end

            if done then
                break
            else
                result = this.mp.run(consume result, this.mapf, this.reducef)
            end
        end
        consume result
    end

    --def isDone()

    def setStartNode(id:int, input:Bighash[int,Node]) : Bighash[int,Node]
        var output = input.copy()
        var startnode = input.get(id)
        startnode.distance = 0
        startnode.color = 1
        output.put(id,startnode)
        consume output
    end
end

-- if node is gray -> for n in ajdList: create gray dist node with (d+1) + emit(oldnode.black)
-- if black or white -> emit(node)
fun map(key:int,value:Node) : [(int, Node)]
    if value.color == 1 then
        value.color = 0
        var adjList = value.adjList
        var result = new[(int,Node)](|adjList|+1)
        val d = value.distance
        repeat i <- |adjList| do
            var dist = new Node(-1) -- Distance Node
            dist.distance = d+1
            dist.color = 1
            var id = adjList(i).id
            result(i) = (id,dist)
        end
        result(|adjList|) = (key,value)
        result
    else
        [(key,value)]
    end
end

-- emit node with, adjList, darkest color and the minimum distance
fun reduce(key:int, values:[Node]) : (int, Node)
    var dmin = 100
    var node = new Node(-1)
    var color = 2
    for d <- values do
        if d.id >= 0 then
            node = d
        else
            if d.distance < dmin then
                dmin = d.distance
            end
        end
        if d.color < color then color = d.color end
    end
    if node.distance > dmin then node.distance = dmin end
    node.color = color
    (key,node)
end
