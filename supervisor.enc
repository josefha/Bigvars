
module Supervisor

import Worker

passive class Supr[t]
    var numofworkers: int
    var size : int
    var workers : [(Worker[t],int,int)]
    var type : t

    def init(data:[t]) : unit
        this.numofworkers = 4
        this.workers = this.split(data,this.numofworkers)
    end

    -- Creating Workers and splitting the data evenly
    def split(data: [t], numofsplits: int) : [(Worker[t],int,int)]
        this.size = |data|
        var rest = this.size % numofsplits
        var splitsize = (this.size  - rest) / numofsplits

        var splits = new [(Worker[t],int,int)](numofsplits)
        var shift = 0
        repeat i <- |splits| do
            var first = splitsize*i
            var last = splitsize*(i+1)-1
            if i >= |splits|-rest then
                if i == |splits|-rest then
                    splits(i) = this.splitdata(data,first,last+1)
                    shift += 1
                else
                    splits(i) = this.splitdata(data,first+shift,last+shift+1)
                    shift += 1
                end
            else
                splits(i) = this.splitdata(data,first,last)
            end
        end
        splits
    end

    -- inserts correct data into worker and returns what indexes they hold
    def splitdata(data:[t],start:int,last:int) : (Worker[t],int,int)
        var splitsize = last-start+1
        var split = new [t](splitsize)
        repeat index <- splitsize do
            split(index) = data(start+index)
        end
        var worker = new Worker[t](split)
        (worker,start,last)
    end

    def atindex(index: int) : t
        var owner = this.ownerinfo(index)
        var worker = owner.0
        get(worker ! atindex(index-owner.1))
    end

    -- Returns a touple with worker holding index and index range
    def ownerinfo(index: int) : (Worker[t],int,int)
        var windex = 0
        repeat i <- |this.workers| do
            if(index >= this.workers(i).1) && (index <= this.workers(i).2) then
                windex = i
            end
        end
        this.workers(windex)
    end

    def windex(i:int, w:(Worker[t],int,int)) : int
      i - w.1
    end

    def applyto(index:int, f : t -> t) : unit
        var workerinfo = this.ownerinfo(index)
        var worker = workerinfo.0
        worker ! applyto(this.windex(index,workerinfo),f)
    end

    def map(f : t -> t) : unit
      for worker <- this.workers do
        var w = worker.0
        w ! map(f)
      end
    end

    -- not the best implementation
    def toarray() : [t]
        var array = new[t](this.size)
        var workerarrays = new[[t]](|this.workers|)
        repeat i <- |this.workers| do
            var worker = this.workers(i).0
            workerarrays(i) =  get(worker ! toarray())
        end

        var arrayindex = 0
        repeat w <- |workerarrays| do
            var workerarray = workerarrays(w)
            repeat i <- |workerarray| do
                array(arrayindex) = workerarray(i)
                arrayindex += 1
            end
        end
        array
    end

    def printArray(f:t->String) : unit
        var result = "["
        var array = this.toarray()
        repeat i <- |array| do
            if (i != |array|-1) then
                result = result.concatenate(f(array(i))).concatenate(",")
            else
                result = result.concatenate(f(array(i)))
            end
        end
        result = result.concatenate("]")
        println(result)
    end
end
