
module Supervisor

import Worker

passive class Supr[t]
    var numofworkers: int
    var size : int
    var workers : [(Worker[t],int,int)]
    var type : t

    def init(data:[t]) : unit
        this.numofworkers = 4
        this.workers = this.split(data,this.numofworkers)
    end

    -- Creating Workers and splitting the data evenly
    def split(data: [t], numofsplits: int) : [(Worker[t],int,int)]
        this.size = |data|
        var rest = this.size % numofsplits
        var splitsize = (this.size  - rest) / numofsplits

        var splits = new [(Worker[t],int,int)](numofsplits)
        var shift = 0
        repeat i <- |splits| do
            var first = splitsize*i
            var last = splitsize*(i+1)-1
            if i >= |splits|-rest then
                if i == |splits|-rest then
                    splits(i) = this.splitdata(data,first,last+1)
                    shift += 1
                else
                    splits(i) = this.splitdata(data,first+shift,last+shift+1)
                    shift += 1
                end
            else
                splits(i) = this.splitdata(data,first,last)
            end
        end
        splits
    end

    -- inserts correct data into worker and returns what indexes they hold
    def splitdata(data:[t],start:int,last:int) : (Worker[t],int,int)
        var splitsize = last-start+1
        var split = new [t](splitsize)
        repeat index <- splitsize do
            split(index) = data(start+index)
        end
        var worker = new Worker[t](split)
        (worker,start,last)
    end

    def printinfo() : unit
        println("Total number of elements: {}", this.size)
        repeat i <- |this.workers| do
            var w = this.workers(i)
            println("Worker {}: index {}-{} : [{}]",i+1,w.1, w.2, (w.2-w.1+1))
        end
    end

    def atindex(index: int) : t
        var owner = this.ownerinfo(index)
        var worker = owner.0
        get(worker ! atindex(index-owner.1))
    end

    -- Returns a touple with worker holding index and index range
    def ownerinfo(index: int) : (Worker[t],int,int)
        var windex = 0
        repeat i <- |this.workers| do
            if(index >= this.workers(i).1) && (index <= this.workers(i).2) then
                windex = i
            end
        end
        this.workers(windex)
    end

    def windex(i:int, w:(Worker[t],int,int)) : int
      i - w.1
    end

    def applyto(index:int, f : t -> t) : unit
        var workerinfo = this.ownerinfo(index)
        var worker = workerinfo.0
        worker ! applyto(this.windex(index,workerinfo),f)
    end

    def map(f : t -> t) : unit
      for worker <- this.workers do
        var w = worker.0
        w ! map(f)
      end
    end

    -- not the best implementation
    def toarray() : [t]
        var array = new[t](this.size)
        var workerarrays = new[[t]](|this.workers|)
        repeat i <- |this.workers| do
            var worker = this.workers(i).0
            workerarrays(i) =  get(worker ! toarray())
        end

        var arrayindex = 0
        repeat w <- |workerarrays| do
            var workerarray = workerarrays(w)
            repeat i <- |workerarray| do
                array(arrayindex) = workerarray(i)
                arrayindex += 1
            end
        end
        array
    end

    def printArray(f:t->String) : unit
        var result = "["
        var array = this.toarray()
        repeat i <- |array| do
            if (i != |array|-1) then
                result = result.concatenate(f(array(i))).concatenate(",")
            else
                result = result.concatenate(f(array(i)))
            end
        end
        result = result.concatenate("]")
        println(result)
    end

    def getStringData(f: t -> String) : [String]
        var values = new[String](this.size)
        var array = this.toarray()
        repeat i <- |array| do
            values(i) = f(array(i))
        end
        values
    end

    def getindexofworkerholding(index: int) : int
        var windex = 0
        repeat i <- |this.workers| do
            if(index >= this.workers(i).1) && (index <= this.workers(i).2) then
                windex = i
                break
            end
        end
        windex
    end

    def insert(index: int, value: t): unit
        this.size += 1
        var windex = this.getindexofworkerholding(index)

        repeat i <- |this.workers| do
            var worker = this.workers(i)
            if(i == windex) then
                this.workers(i) = (worker.0,worker.1,worker.2+1)
            else if(i > windex) then
                this.workers(i) = (worker.0,worker.1+1,worker.2+1)
            end
        end
        var worker = this.workers(windex)
        var localindex = this.windex(index,worker)
        var w = worker.0

        w ! insert(localindex,value)
    end

    def delete(index: int): unit
        this.size -= 1
        var windex = this.getindexofworkerholding(index)

        repeat i <- |this.workers| do
            var worker = this.workers(i)
            if ((worker.2-worker.1)> 0) then
                if(i == windex) then
                    this.workers(i) = (worker.0,worker.1,worker.2-1)
                else if(i > windex) then
                    this.workers(i) = (worker.0,worker.1-1,worker.2-1)
                end
            end
        end
        var worker = this.workers(windex)
        var localindex = this.windex(index,worker)
        var w = worker.0

        w ! delete(localindex)
    end

    def push(value: t) : unit
        this.size += 1
        var worker = this.workers(|this.workers|-1)
        this.workers(|this.workers|-1) = (worker.0,worker.1,worker.2+1)

        var w = worker.0
        w ! push(value)
    end

    def getif(f: t -> bool) : [t]

        -- var result = new[[t]](this.numofworkers)
        -- --
        --
        -- repeat i <- |this.workers| do
        --     --workerresult = new[t](this.numofworkers)
        --     var w = this.workers(i).0
        --     result(i) = w ! getif(f)
        -- end
        --
        -- repeat i <- |this.workers| do
        --     var w = this.workers(i).0
        --     get(result(i))
        -- end

        this.toarray()

    end

    -- var array = new[t](this.size)
    -- var workerarrays = new[[t]](|this.workers|)
    -- repeat i <- |this.workers| do
    --     var worker = this.workers(i).0
    --     workerarrays(i) =  get(worker ! toarray())
    -- end
    --
    -- var arrayindex = 0
    -- repeat w <- |workerarrays| do
    --     var workerarray = workerarrays(w)
    --     repeat i <- |workerarray| do
    --         array(arrayindex) = workerarray(i)
    --         arrayindex += 1
    --     end
    -- end
    -- array

end
