
module MapReduce

import Bighash
import HashEntry

local class MapReduce[sharable k1,sharable v1,sharable k2,sharable v2]

    var hasher : k2 -> uint

    def init(hasher: k2 -> uint): unit
        this.hasher = hasher
    end

    def run(data:Bighash[k1,v1], m:(k1,v1)->[(k2,v2)], r:(k2,[v2]) -> (k2,v2)): Bighash[k2,v2]
        ------- Mapper -----------
        var map_result = new Bighash[k2,v2](this.hasher)
        var sender = map_result.copy()
        data.mapper[k2,v2](m,consume sender)
        ------- Reducer ----------
        var reduce_result = new Bighash[k2,v2](this.hasher)
        var reduce_c = reduce_result.copy()
        map_result.reducer(r,consume reduce_c)
        ------- Result -----------
        consume reduce_result
    end
end

local class Combiner[sharable k,sharable v]
    var tableSize : int
    var table : [HashEntry[k,v]]

    def init(size: int) : unit
        this.tableSize = size
        this.table = new[HashEntry[k,v]](size)
        repeat i <- this.tableSize do
            this.table(i) = new HashEntry[k,v]()
        end
    end

    def combine(reduce:(k,[v]) -> (k,v), bighash:Bighash[k,v]) : unit
        repeat i <- this.tableSize do
            var entry = this.table(i)
            if entry.notEmpty() then
                var key = entry.getKey()
                if (entry.size() == 1) then
                    var value = entry.getValue()
                    bighash.extend(key,value)
                else
                    var values = entry.getValues()
                    var pair = reduce(key,values)
                    bighash.extend(key,pair.1)
                end
            end
        end
    end

    def extend(key:k,value:v,hashValue:uint) : unit
        var hashentry = this.getEntry(hashValue)
        hashentry.extend(key,value,hashValue)
    end

    def getEntry(hashValue:uint) : HashEntry[k,v]
        var entryID = this.modulo(hashValue,this.tableSize)
        var hashentry = this.table(entryID)
        while ((hashentry.notEmpty()) && (hashentry.getHash() != hashValue)) do
            entryID = this.modulo(entryID+1,this.tableSize)
            hashentry = this.table(entryID)
        end
        hashentry
    end

    def modulo(value : uint, mod : uint) : uint
      EMBED (uint)
        uint64_t value = (uint64_t) #{value};
              uint64_t mod   = (uint64_t) #{mod};
              (value % mod);

      END
    end
end
