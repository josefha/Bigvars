
import MapReduce
import Bighash
import Siphash

EMBED
  #include <stdint.h> // uintptr_t
BODY
END

active class Main
    def main() : unit
        --println("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
        testHash()
        --
        var input = dataInput().split("\n")
        -- a = 5
        -- b = 7
        -- c = 5
        -- d = 5
        --

        var data = generateFromStringArray(["a b c a b c c c","a a b a", "b b b"])--, "a a","b b","c b", "b d", "c d d d","d c b  a e"])--,"vad du hej hej","asdasd jkjk jka asd pÃ¥ok", "lkas asdkllkj hej amklkljqwsd", "agfasdgd dfsg"]) -- bigvar

        var stringID = fun(k:String) => stringID_NEW(k)
        var intID = fun(k:int) => intID(k)

        var mapReduce = new MapReduce[int,String,String,int,int](stringID)

        var mapf = fun(key:int,value:String) => map(key,value)
        var reducef = fun(key:String,values:[int]) => reduce(key,values)
        -- Running
        var result = mapReduce.run(data, mapf, reducef)


        var bighash = new Bighash[String,int](stringID)
        --[Fut[[[(v,k)]]]]
        for workerResult <- result do
            --Fut[[[(v,k)]]]
            var workerData = get(workerResult)
            --[[(v,k)]]
            repeat i <- |workerData| do
                for pairs <- workerData do
                    --[(v,k)]

                    for pair <- pairs do
                        println(pair)
                        bighash.extend(pair.0,pair.1)
                    end
                end
            end
        end

        var keys = bighash.keys()

        repeat i <- |keys| do
            var values = bighash.getValues(keys(i))

            var count = 0
            for value <- values do
                count += 1
            end
            println("    {} --  {}", keys(i), count)
        end
        ()
    end
end

fun map(key:int,value:String) : [(String,int)]
    println("\n --------------------")
    var words = value.split(" ")
    var result = new[(String,int)](|words|)
    print("\n'{}' - ",value)
    repeat i <- |words| do
        result(i) = (words(i),1)
        print(result(i))
    end

    result
end

fun reduce(key:String,values:[int]) : (String,int)
    var sum = 0
    for value <- values do
        sum += value
    end
    (key,sum)
end

local class Str : HashCode
    var hash_code : uint
    def init(str:String) : unit
        var stringID = fun(k:String) => EMBED (uint) (uint64_t) #{k.getData()}; END
        this.hash_code = stringID(str)
    end
end

fun testHash() : unit
    ()
    -- var hashtable = new Bighash[String, int](fun(k:String) => stringID_NEW(k))
    --
    --
    --
    --
    -- var key1 = new Str("1000")
    -- var key2 = new Str("111")
    -- var key3 = new Str("222222")
    -- var key4 = new Str("555555")
    -- var key5 = new Str("111")
    -- var key6 = new Str("1000")
    --
    -- var hash = new Siphash()
    --
    -- println("1 : {}", hash.hash(key1.get_hash()))
    -- println("2 : {}", hash.hash(key2.get_hash()))
    -- println("3 : {}", hash.hash(key3.get_hash()))
    -- println("4 : {}", hash.hash(key4.get_hash()))
    -- println("5 : {}", hash.hash(key5.get_hash()))
    -- println("6 : {}", hash.hash(key6.get_hash()))


    --
    -- --var pointer1 = EMBED (uint) (uint64_t) #{key1.getData()}; END
    --
    -- hashtable.put("10",11111)
    -- hashtable.put(key2,21222)
    -- hashtable.extend("10",333333)
    -- hashtable.extend("11",444444)
    -- hashtable.extend("323",444444)
    -- -- hashtable.extend("53454",444444)
    -- -- hashtable.extend("123",444444)
    -- --println(hashtable.get("11"))
    --
    -- var values = hashtable.keys() --getValues("11")
    -- for value <- values do
    --     print("values: ")
    --     println(value)
    --     println(hashtable.get(value))
    -- end
    --
    -- println("----------------------")---------------------------------

    -- var hashtable2 = new Bighash[int, String](fun(k:int) => intID(k))
    --
    --
    -- hashtable2.put(11,"OMG 11111")
    -- hashtable2.put(123123,"123123123")
    -- hashtable2.extend(123123,"tjatjat")
    -- println(hashtable2.get(11))
end

fun dataInput() : String
    "The Programming Languages Group at Uppsala University is developing a programming language called Encore.
    Encore is a object oriented language with the actor model and a focus on parallelism.
    The compiler is written in Haskell and translates Encore code to C code, which can then be compiled with a C compiler.
    The project assignment is to extend the features of Encore and implement a library for Bigvars.
    'Arrays in Encore are stored in one actor resulting in operations on arrays being executed sequentially.
    Encore is also lacking syntactic support for easy programming of data structures distributed across actors.
    Bigvars will be a data type with a collection of values that are distributed among many actors.
    Operations on Bigvars could therefor be executed in parallel.
    Bigvars would also make it easier syntactically for the programer to programming with big collections of data.
    For example if you have an Bigvar of customer objects,
    then doing `.account` would automatically apply the `.account` method to all customers.
    One possible implementation of Bigvars in Encore would be to split the data between many
    actors and have all those actors report to other actors that act like supervisors.
    The supervisors would coordinate all workers and hold meta information about specific parts of the Bigvar.
    I will start the project with researching similar implementation in other languages, like Julias distributed arrays and Java 8 parallel streams.
    I will then decide how to best implement Bigvars in Encore.
    Most of the time will be spent on the actually implementation, Bigvars will be implemented as a library written in Encore.
    The first step of the implementation part will be to provide support for distributed arrays with basic array functionality
    and with a fixed number of underlying actors. The second step will be to have a dynamic number of underlaying actors and add
    some advanced functionality like object method calls and math functions. The third step will be to provide similar support
    as for distributed arrays to distributed Hash-tables. Lastly research if syntactical support from the encore compiler is
    needed and if it is devise a syntax, a compilation scheme and implement it. Also investigate and possible implement support
    for more datatypes such as distributed Sets. Tests and measurements of my implementation is also a priority.
    The Programming Languages Group at Uppsala University is developing a programming language called Encore.
    Encore is a object oriented language with the actor model and a focus on parallelism.
    The compiler is written in Haskell and translates Encore code to C code, which can then be compiled with a C compiler.
    The project assignment is to extend the features of Encore and implement a library for Bigvars.
    'Arrays in Encore are stored in one actor resulting in operations on arrays being executed sequentially.
    Encore is also lacking syntactic support for easy programming of data structures distributed across actors.
    Bigvars will be a data type with a collection of values that are distributed among many actors.
    Operations on Bigvars could therefor be executed in parallel.
    Bigvars would also make it easier syntactically for the programer to programming with big collections of data.
    For example if you have an Bigvar of customer objects,
    then doing `.account` would automatically apply the `.account` method to all customers.
    One possible implementation of Bigvars in Encore would be to split the data between many
    actors and have all those actors report to other actors that act like supervisors.
    The supervisors would coordinate all workers and hold meta information about specific parts of the Bigvar.
    I will start the project with researching similar implementation in other languages, like Julias distributed arrays and Java 8 parallel streams.
    I will then decide how to best implement Bigvars in Encore.
    Most of the time will be spent on the actually implementation, Bigvars will be implemented as a library written in Encore.
    The first step of the implementation part will be to provide support for distributed arrays with basic array functionality
    and with a fixed number of underlying actors. The second step will be to have a dynamic number of underlaying actors and add
    some advanced functionality like object method calls and math functions. The third step will be to provide similar support
    as for distributed arrays to distributed Hash-tables. Lastly research if syntactical support from the encore compiler is
    needed and if it is devise a syntax, a compilation scheme and implement it. Also investigate and possible implement support
    for more datatypes such as distributed Sets. Tests and measurements of my implementation is also a priority.
    end"
end

local trait HashCode
  require var hash_code : uint
  def hash_adress() : uint
    EMBED (int)
      // Hashing-key, can be any random bytes
      uint8_t k[16] = {
          0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07, // k0
          0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f  // k1
      };

      // Allocate 8 bytes on the stack for the hashcode
      uint8_t hash[8];

      // Retrieve adress of this object
      uintptr_t adress = (uintptr_t) _this;

      // Convert the adress to an uint8_t-array
      // WARNING: Assumes little endian!
      size_t ptr_size = sizeof(uintptr_t);
      uint8_t adress_arr[ptr_size];
      for(int i = 0; i < ptr_size; ++i) {
          adress_arr[i] = (uint8_t)((adress) >> i*8);
      }

      // Compute the hash value
      // WARNING: size_t may be larger than uint64_t !!!
      siphash(hash, adress_arr, (uint64_t) ptr_size, k);

      // Return the value to the caller
      U8TO64_LE(hash);
    END
  end

  def get_hash() : uint
    this.hash_code
  end

  def equals(other : HashCode) : bool
    this.hash_code == other.get_hash()
  end
end
